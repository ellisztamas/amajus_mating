# Mating patterns in Antirrhinum majus

## 0.3.0 Summarise mating patterns

10th September 2021

For a single set of parameters, summarise what information we would like to know
about mating patterns by calling summarise_sires()

- Import a set of MCMC chains, concatenate, and reduce to 1000 rows.
- For a single row in that matrix: 
    - Update paternity probabilities with values from the step in the MCMC
    - Draw two posterior samples of mating events using:
        1. genetic and dispersal information
        2. Dispersal information only
    - Join those to data on flower colour and distances between parents.
    - Create a function `mating.fathers()` to summarise conclusions about the
        output (for the table including genetic information):
            - Weighted-median dispersal distance
            - How many more than 500 or 1000m?
            - How many mating patterns:
                1. How many in total (sum of 'prob' column)
                2. How many have >95% support
            - How many missing fathers?
            - How many offspring have an unsampled father?
    - Create a function `mating.fitness()` to compare mating patterns between
        the two posterior samples:
            - Relative fitness of genotypes also across space?
            - Assortment?
- Repeat `mating.fathers()` and `mating.fitness()` for every row in the MCMC
    chain.
- Create a single table in the format of `summarise_sires` which is an *average*
    over the MCMC output.
        - Create a blank DataFrame with headers that match `summarise_sires`.
        - For each MCMC step, do an inner join on the `mother` and `father` 
            columns.
        - Sum the two resulting `prob` columns.
        - Select only the columns in the original format.
        - Repeat for all MCMC steps.
        - Use this to generate a single dispersal kernel.

## 0.2.0 Mating with out covariates

25th August 2021

An analysis of sibships and paternity without including information about 
dispersal to get a first impression of the dataset (I should have done this a 
long time ago). I am using the 'full integration' version of the transition
probabilty function, which has recently been validated with data from American
chestnut, and I am a bit more confident about the data.

How many mating events?
How big are the families?
How many missing fathers?

Added folder `005.results/003_no_covariates`.
Changed the names of other results folders to fit that in.

## 0.1.0 Paternity by full integration
19.08.2021, on branch 'full-integration'

I have adapted the MCMC procedure to use `integration='full'`.
This ought to be a better implementation of the function to calculate transition
probabilties, but I previously couldn't get MCMC to work. I think that was 
because the proportion of missing fathers was allowed to vary, but there is a
high likelihood solution where everybody's father is missing, and the algorithm 
coverged on that. Even strong priors were not enough to stop it.
To address this I now use fixed values for missing fathers, but use a different
value for each MCMC chain (0.1, 0.2, 0.3, and 0.4).

I was also previously starting my chains from random draws from the prior for 
each parameter. This took ages to converge, but I still didn't want to change 
the priors. Instead, initial conditions are now defined with a list of manually
defined values, which are parsed with a loop. I can reuse this for other results
using different priors without having to create a ton of scripts and risk
copy-paste errors.

During convergence I found that shape and scale parameters sometimes wander
below zero or above one. I had to update `mcmc.update_parameters` so that when
this happens, values are reflected back on themselved. For example:

1. if a value of -0.01 is proposed, this becomes 0.01. 
2. If a value of 1.01 is proposed for something bounded by 1, this becomes
    2-1.01 = 0.99.

Chain mixing is a bit weird - it seems that having fixed values for missing dads
that are different between chains makes it hard to compare chains. It may be
I need to use one value, and repeat the whole excercise later with higher and 
lower values

Also updated MCMC log files to also print the version of Python being used.

Updated the library package to 0.3.1.